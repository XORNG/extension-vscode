import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { exec, spawn } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Docker service status
 */
export interface ServiceStatus {
  name: string;
  running: boolean;
  containerId?: string;
  ports?: string[];
  health?: 'healthy' | 'unhealthy' | 'starting' | 'none';
}

/**
 * DockerManager - Manages Docker containers for XORNG infrastructure services
 * 
 * Handles:
 * - Redis for memory system
 * - Health checks for services
 * - Docker Compose lifecycle
 */
export class DockerManager implements vscode.Disposable {
  private globalStoragePath: string;
  private outputChannel: vscode.OutputChannel;
  private disposables: vscode.Disposable[] = [];
  private composeFilePath: string;

  constructor(context: vscode.ExtensionContext) {
    this.globalStoragePath = context.globalStorageUri.fsPath;
    this.composeFilePath = path.join(this.globalStoragePath, 'docker-compose.yml');
    this.outputChannel = vscode.window.createOutputChannel('XORNG Docker');
    this.disposables.push(this.outputChannel);
  }

  /**
   * Check if Docker is available on the system
   */
  async isDockerAvailable(): Promise<boolean> {
    try {
      await execAsync('docker --version');
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check if Docker Compose is available
   */
  async isDockerComposeAvailable(): Promise<boolean> {
    try {
      // Try docker compose (v2) first
      await execAsync('docker compose version');
      return true;
    } catch {
      try {
        // Fall back to docker-compose (v1)
        await execAsync('docker-compose --version');
        return true;
      } catch {
        return false;
      }
    }
  }

  /**
   * Get the appropriate Docker Compose command
   */
  private async getComposeCommand(): Promise<string> {
    try {
      await execAsync('docker compose version');
      return 'docker compose';
    } catch {
      return 'docker-compose';
    }
  }

  /**
   * Check if Docker daemon is running
   */
  async isDockerRunning(): Promise<boolean> {
    try {
      await execAsync('docker info');
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Ensure the Docker Compose file exists
   */
  async ensureComposeFile(): Promise<void> {
    // Ensure storage directory exists
    await fs.promises.mkdir(this.globalStoragePath, { recursive: true });

    // Write/update the compose file
    const composeContent = this.generateComposeFile();
    await fs.promises.writeFile(this.composeFilePath, composeContent, 'utf-8');
    this.log('Docker Compose file created/updated');
  }

  /**
   * Generate Docker Compose file content for infrastructure services
   */
  private generateComposeFile(): string {
    return `# XORNG Infrastructure Services
# Auto-generated by XORNG VS Code Extension
# Do not edit manually - changes will be overwritten

services:
  # Redis for memory system (short-term, entity memory, pub/sub)
  redis:
    image: redis:7-alpine
    container_name: xorng-redis
    ports:
      - "6379:6379"
    volumes:
      - xorng-redis-data:/data
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 3s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped
    labels:
      - "xorng.managed=true"
      - "xorng.service=redis"

volumes:
  xorng-redis-data:
    name: xorng-redis-data
`;
  }

  /**
   * Start all infrastructure services
   */
  async startServices(progress?: vscode.Progress<{ message?: string; increment?: number }>): Promise<boolean> {
    try {
      // Check prerequisites
      if (!await this.isDockerAvailable()) {
        throw new Error('Docker is not installed. Please install Docker Desktop or Docker Engine.');
      }

      if (!await this.isDockerRunning()) {
        throw new Error('Docker daemon is not running. Please start Docker Desktop or the Docker service.');
      }

      if (!await this.isDockerComposeAvailable()) {
        throw new Error('Docker Compose is not available. Please ensure Docker Compose is installed.');
      }

      progress?.report({ message: 'Preparing Docker configuration...' });
      await this.ensureComposeFile();

      progress?.report({ message: 'Starting infrastructure services...' });
      const composeCmd = await this.getComposeCommand();
      
      this.log(`Running: ${composeCmd} up -d`);
      
      const { stdout, stderr } = await execAsync(
        `${composeCmd} -f "${this.composeFilePath}" up -d`,
        { cwd: this.globalStoragePath }
      );
      
      if (stdout) this.log(stdout);
      if (stderr) this.log(stderr);

      progress?.report({ message: 'Waiting for services to be healthy...' });
      
      // Wait for Redis to be healthy (60s timeout for slower systems)
      const healthy = await this.waitForHealthy('xorng-redis', 60000);
      
      if (!healthy) {
        throw new Error('Redis failed to become healthy within timeout');
      }

      this.log('✓ All infrastructure services started successfully');
      return true;

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      this.log(`✗ Failed to start services: ${errorMsg}`);
      throw error;
    }
  }

  /**
   * Stop all infrastructure services
   */
  async stopServices(): Promise<void> {
    try {
      if (!await this.isDockerAvailable() || !await this.isDockerRunning()) {
        return;
      }

      const composeCmd = await this.getComposeCommand();
      
      this.log('Stopping infrastructure services...');
      
      await execAsync(
        `${composeCmd} -f "${this.composeFilePath}" stop`,
        { cwd: this.globalStoragePath }
      );

      this.log('✓ Infrastructure services stopped');

    } catch (error) {
      this.log(`Warning: Failed to stop services: ${error}`);
    }
  }

  /**
   * Stop and remove all infrastructure services and volumes
   */
  async removeServices(): Promise<void> {
    try {
      if (!await this.isDockerAvailable() || !await this.isDockerRunning()) {
        return;
      }

      const composeCmd = await this.getComposeCommand();
      
      this.log('Removing infrastructure services...');
      
      await execAsync(
        `${composeCmd} -f "${this.composeFilePath}" down -v`,
        { cwd: this.globalStoragePath }
      );

      this.log('✓ Infrastructure services removed');

    } catch (error) {
      this.log(`Warning: Failed to remove services: ${error}`);
    }
  }

  /**
   * Get status of all services
   */
  async getServicesStatus(): Promise<ServiceStatus[]> {
    const services: ServiceStatus[] = [];

    try {
      if (!await this.isDockerAvailable() || !await this.isDockerRunning()) {
        return [{ name: 'redis', running: false }];
      }

      // Check Redis container
      const redisStatus = await this.getContainerStatus('xorng-redis');
      services.push(redisStatus);

    } catch (error) {
      this.log(`Failed to get service status: ${error}`);
      services.push({ name: 'redis', running: false });
    }

    return services;
  }

  /**
   * Get status of a specific container
   */
  private async getContainerStatus(containerName: string): Promise<ServiceStatus> {
    try {
      // Use Go template format - more reliable across platforms than JSON
      const { stdout } = await execAsync(
        `docker inspect --format "{{.Id}}|{{.State.Running}}|{{.State.Health.Status}}" ${containerName}`
      );
      
      const parts = stdout.trim().split('|');
      const containerId = parts[0] || '';
      const running = parts[1] === 'true';
      const healthRaw = parts[2] || 'none';
      // Handle '<no value>' which Docker returns when no healthcheck is defined
      const health = healthRaw === '<no value>' ? 'none' : healthRaw;
      
      // Get port mappings
      let ports: string[] = [];
      try {
        const { stdout: portsOutput } = await execAsync(
          `docker port ${containerName}`
        );
        ports = portsOutput.trim().split('\n').filter(Boolean);
      } catch {
        // Port query can fail if container isn't fully ready
      }

      return {
        name: containerName.replace('xorng-', ''),
        running,
        containerId: containerId.substring(0, 12),
        ports,
        health: health as ServiceStatus['health'],
      };

    } catch (error) {
      // Container doesn't exist yet or other error
      this.log(`getContainerStatus error for ${containerName}: ${error}`);
      return {
        name: containerName.replace('xorng-', ''),
        running: false,
        health: 'none',
      };
    }
  }

  /**
   * Wait for a container to become healthy
   */
  private async waitForHealthy(containerName: string, timeoutMs: number): Promise<boolean> {
    const startTime = Date.now();
    const checkInterval = 2000; // Check every 2 seconds
    let lastStatus = '';

    this.log(`Waiting for ${containerName} to become healthy (timeout: ${timeoutMs / 1000}s)...`);

    while (Date.now() - startTime < timeoutMs) {
      const status = await this.getContainerStatus(containerName);
      const currentStatus = `running=${status.running}, health=${status.health}`;
      
      // Log status changes
      if (currentStatus !== lastStatus) {
        this.log(`  ${containerName}: ${currentStatus}`);
        lastStatus = currentStatus;
      }
      
      if (status.running && status.health === 'healthy') {
        this.log(`✓ ${containerName} is healthy`);
        return true;
      }
      
      // Only fail immediately if container exited (not just not found during startup)
      if (status.health === 'unhealthy') {
        this.log(`✗ ${containerName} is unhealthy - checking logs...`);
        await this.logContainerLogs(containerName);
        return false;
      }

      await this.sleep(checkInterval);
    }

    // On timeout, get more diagnostic info
    this.log(`✗ Timeout waiting for ${containerName} to be healthy`);
    await this.logContainerLogs(containerName);
    return false;
  }

  /**
   * Log recent container logs for debugging
   */
  private async logContainerLogs(containerName: string): Promise<void> {
    try {
      const { stdout, stderr } = await execAsync(`docker logs --tail 20 ${containerName} 2>&1`);
      this.log(`Recent logs from ${containerName}:`);
      this.log(stdout || stderr || '(no logs available)');
    } catch (error) {
      this.log(`Could not retrieve logs for ${containerName}: ${error}`);
    }
  }

  /**
   * Check if Redis is ready and accepting connections
   */
  async isRedisReady(): Promise<boolean> {
    try {
      const { stdout } = await execAsync('docker exec xorng-redis redis-cli ping');
      return stdout.trim() === 'PONG';
    } catch {
      return false;
    }
  }

  /**
   * Get Redis connection URL for the Core
   */
  getRedisUrl(): string {
    // Redis is exposed on localhost:6379 from the container
    return 'redis://localhost:6379';
  }

  /**
   * Sleep helper
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Log message
   */
  private log(message: string): void {
    const timestamp = new Date().toISOString();
    this.outputChannel.appendLine(`[${timestamp}] ${message}`);
  }

  /**
   * Show output channel
   */
  showOutput(): void {
    this.outputChannel.show();
  }

  /**
   * Dispose resources
   */
  dispose(): void {
    this.disposables.forEach(d => d.dispose());
  }
}
